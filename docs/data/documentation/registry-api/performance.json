{"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","interfaceLanguage":"openapi"},"metadata":{"title":"Performance Optimization","modules":[{"name":"Registry API"}],"roleHeading":"Article","role":"article"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Optimizing your interactions with the Swift Package Registry API can significantly improve your application’s performance and user experience. This guide covers best practices for efficient API usage, including caching strategies, concurrent requests, and optimizing data transfers."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"anchor":"Caching-Strategies","text":"Caching Strategies","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Implementing effective caching is one of the most important ways to improve performance when working with the Registry API."}],"type":"paragraph"},{"anchor":"Memory-Caching","text":"Memory Caching","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"For frequently accessed data that doesn’t change often, implement in-memory caching:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class RegistryAPIClient {","    \/\/ Simple memory cache with expiration support","    private class Cache<K: Hashable, V> {","        private struct CacheEntry {","            let value: V","            let expirationDate: Date","        }","        ","        private var storage = [K: CacheEntry]()","        private let lock = NSLock()","        ","        func set(_ value: V, forKey key: K, expirationInterval: TimeInterval) {","            lock.lock()","            defer { lock.unlock() }","            ","            let expirationDate = Date().addingTimeInterval(expirationInterval)","            storage[key] = CacheEntry(value: value, expirationDate: expirationDate)","        }","        ","        func get(forKey key: K) -> V? {","            lock.lock()","            defer { lock.unlock() }","            ","            guard let entry = storage[key], entry.expirationDate > Date() else {","                \/\/ Remove expired entry if it exists","                storage.removeValue(forKey: key)","                return nil","            }","            ","            return entry.value","        }","        ","        func removeAll() {","            lock.lock()","            defer { lock.unlock() }","            storage.removeAll()","        }","    }","    ","    \/\/ Cache for package metadata (larger TTL since metadata changes less frequently)","    private let metadataCache = Cache<String, PackageMetadata>()","    ","    \/\/ Cache for package identifiers (shorter TTL since search results may change)","    private let identifierCache = Cache<String, [Identifier]>()","    ","    func fetchPackageMetadata(scope: String, name: String) async throws -> PackageMetadata {","        let cacheKey = \"\\(scope)\/\\(name)\"","        ","        \/\/ Check cache first","        if let cachedMetadata = metadataCache.get(forKey: cacheKey) {","            return cachedMetadata","        }","        ","        \/\/ Fetch from network","        let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","        let (data, _) = try await URLSession.shared.data(from: url)","        let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","        ","        \/\/ Cache result (30 minute TTL)","        metadataCache.set(metadata, forKey: cacheKey, expirationInterval: 30 * 60)","        ","        return metadata","    }","}"]},{"anchor":"Persistent-Caching","text":"Persistent Caching","type":"heading","level":3},{"inlineContent":[{"text":"For data that should persist between app launches:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class PersistentCache {","    private let fileManager = FileManager.default","    private let cacheDirectory: URL","    ","    init() throws {","        let cacheURL = try fileManager.url(","            for: .cachesDirectory, ","            in: .userDomainMask, ","            appropriateFor: nil, ","            create: true","        )","        cacheDirectory = cacheURL.appendingPathComponent(\"RegistryCache\", isDirectory: true)","        ","        if !fileManager.fileExists(atPath: cacheDirectory.path) {","            try fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)","        }","    }","    ","    func cacheData(_ data: Data, forKey key: String, expirationInterval: TimeInterval) throws {","        let fileURL = cacheDirectory.appendingPathComponent(key.md5Hash)","        try data.write(to: fileURL)","        ","        \/\/ Store metadata including expiration","        let metadata: [String: Any] = [","            \"key\": key,","            \"expiration\": Date().addingTimeInterval(expirationInterval).timeIntervalSince1970","        ]","        let metadataURL = fileURL.appendingPathExtension(\"metadata\")","        let metadataData = try JSONSerialization.data(withJSONObject: metadata)","        try metadataData.write(to: metadataURL)","    }","    ","    func getData(forKey key: String) throws -> Data? {","        let fileURL = cacheDirectory.appendingPathComponent(key.md5Hash)","        let metadataURL = fileURL.appendingPathExtension(\"metadata\")","        ","        \/\/ Check if file exists","        guard fileManager.fileExists(atPath: fileURL.path),","              fileManager.fileExists(atPath: metadataURL.path) else {","            return nil","        }","        ","        \/\/ Check expiration","        let metadataData = try Data(contentsOf: metadataURL)","        let metadata = try JSONSerialization.jsonObject(with: metadataData) as? [String: Any]","        ","        if let expirationTimestamp = metadata?[\"expiration\"] as? TimeInterval,","           Date(timeIntervalSince1970: expirationTimestamp) > Date() {","            \/\/ Not expired, return data","            return try Data(contentsOf: fileURL)","        } else {","            \/\/ Expired, clean up files","            try? fileManager.removeItem(at: fileURL)","            try? fileManager.removeItem(at: metadataURL)","            return nil","        }","    }","}"]},{"anchor":"Conditional-Requests","text":"Conditional Requests","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Use HTTP conditional requests with ETag or Last-Modified headers to avoid downloading unchanged data:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class ConditionalRequestClient {","    private var etagStorage: [String: String] = [:]","    ","    func fetchWithConditionalRequest(url: URL) async throws -> Data {","        var request = URLRequest(url: url)","        ","        \/\/ Add conditional header if we have an ETag","        let resourceKey = url.absoluteString","        if let etag = etagStorage[resourceKey] {","            request.addValue(etag, forHTTPHeaderField: \"If-None-Match\")","        }","        ","        let (data, response) = try await URLSession.shared.data(for: request)","        guard let httpResponse = response as? HTTPURLResponse else {","            throw APIError.invalidResponse","        }","        ","        \/\/ Store ETag if present","        if let newETag = httpResponse.value(forHTTPHeaderField: \"ETag\") {","            etagStorage[resourceKey] = newETag","        }","        ","        if httpResponse.statusCode == 304 {","            \/\/ Resource not modified, return cached data","            guard let cachedData = try PersistentCache().getData(forKey: resourceKey) else {","                throw APIError.cacheInconsistency","            }","            return cachedData","        } else if (200..<300).contains(httpResponse.statusCode) {","            \/\/ New or modified data","            try PersistentCache().cacheData(data, forKey: resourceKey, expirationInterval: 3600)","            return data","        } else {","            throw APIError.httpError(httpResponse.statusCode)","        }","    }","}"]},{"anchor":"Optimizing-Data-Transfers","text":"Optimizing Data Transfers","type":"heading","level":2},{"anchor":"Compression","text":"Compression","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The Registry API supports gzip compression. Enable it in your requests:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var request = URLRequest(url: url)","request.addValue(\"gzip, deflate\", forHTTPHeaderField: \"Accept-Encoding\")"]},{"anchor":"Request-Only-What-You-Need","text":"Request Only What You Need","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Use query parameters to limit the data you retrieve:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Example: Limiting the number of results","func searchPackages(query: String, limit: Int = 20) async throws -> [Identifier] {","    let urlString = \"https:\/\/registry.example.com\/identifiers?query=\\(query)&limit=\\(limit)\"","    guard let url = URL(string: urlString) else {","        throw URLError(.badURL)","    }","    ","    let (data, _) = try await URLSession.shared.data(from: url)","    return try JSONDecoder().decode([Identifier].self, from: data)","}"]},{"anchor":"Avoiding-Redundant-Requests","text":"Avoiding Redundant Requests","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Track in-flight requests to avoid duplicate network calls:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class APIRequestCoordinator {","    private var inFlightRequests = [URL: Task<Data, Error>]()","    private let lock = NSLock()","    ","    func performRequest(for url: URL) async throws -> Data {","        lock.lock()","        ","        \/\/ Check if there's already an in-flight request for this URL","        if let existingTask = inFlightRequests[url] {","            lock.unlock()","            return try await existingTask.value","        }","        ","        \/\/ Create a new task for this request","        let task = Task<Data, Error> {","            defer {","                lock.lock()","                inFlightRequests[url] = nil","                lock.unlock()","            }","            ","            let (data, _) = try await URLSession.shared.data(from: url)","            return data","        }","        ","        \/\/ Store the task","        inFlightRequests[url] = task","        lock.unlock()","        ","        return try await task.value","    }","}"]},{"anchor":"Concurrent-Operations","text":"Concurrent Operations","type":"heading","level":2},{"anchor":"Parallel-Downloads","text":"Parallel Downloads","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Download multiple packages in parallel for faster bulk operations:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func downloadMultiplePackages(packages: [(scope: String, name: String, version: String)]) async throws -> [String: Data] {","    \/\/ Create a task for each package","    let tasks = packages.map { package in","        Task {","            let (scope, name, version) = package","            let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\/\\(version).zip\")!","            let (data, _) = try await URLSession.shared.data(from: url)","            return (key: \"\\(scope)\/\\(name)\/\\(version)\", data: data)","        }","    }","    ","    \/\/ Wait for all tasks to complete","    var results = [String: Data]()","    for task in tasks {","        do {","            let (key, data) = try await task.value","            results[key] = data","        } catch {","            \/\/ Handle individual download failures","            print(\"Failed to download package: \\(error.localizedDescription)\")","        }","    }","    ","    return results","}"]},{"anchor":"Task-Prioritization","text":"Task Prioritization","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Use task priorities for critical vs. background operations:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ High-priority task (e.g., user-initiated download)","let highPriorityTask = Task(priority: .userInitiated) {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\/\\(version).zip\")!","    return try await URLSession.shared.data(from: url)","}","","\/\/ Background task (e.g., prefetching)","let backgroundTask = Task(priority: .background) {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","    return try await URLSession.shared.data(from: url)","}"]},{"anchor":"Network-Efficiency","text":"Network Efficiency","type":"heading","level":2},{"anchor":"Connection-Pooling","text":"Connection Pooling","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Configure your URLSession for connection reuse:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let configuration = URLSessionConfiguration.default","configuration.httpMaximumConnectionsPerHost = 6  \/\/ Default is 6","configuration.timeoutIntervalForRequest = 30.0   \/\/ 30 seconds","configuration.timeoutIntervalForResource = 60.0  \/\/ 60 seconds","","let session = URLSession(configuration: configuration)"]},{"anchor":"Batch-Operations","text":"Batch Operations","type":"heading","level":3},{"inlineContent":[{"text":"When possible, use batch operations to reduce round trips:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Instead of multiple separate requests","func batchFetchIdentifiers(queries: [String]) async throws -> [String: [Identifier]] {","    let queryString = queries.joined(separator: \",\")","    let url = URL(string: \"https:\/\/registry.example.com\/identifiers?queries=\\(queryString)\")!","    ","    let (data, _) = try await URLSession.shared.data(from: url)","    return try JSONDecoder().decode([String: [Identifier]].self, from: data)","}"]},{"anchor":"Prefetching-and-Predictive-Loading","text":"Prefetching and Predictive Loading","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Implement predictive loading for a smoother user experience:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class PredictiveLoader {","    private let prefetchQueue = OperationQueue()","    private var prefetchedData = [URL: Data]()","    ","    init() {","        prefetchQueue.maxConcurrentOperationCount = 2","        prefetchQueue.qualityOfService = .utility","    }","    ","    func prefetchRelatedPackages(for package: PackageMetadata) {","        guard let dependencies = package.dependencies else { return }","        ","        for dependency in dependencies {","            let dependencyURL = URL(string: \"https:\/\/registry.example.com\/\\(dependency.scope)\/\\(dependency.name)\")!","            ","            Task(priority: .background) {","                do {","                    let (data, _) = try await URLSession.shared.data(from: dependencyURL)","                    prefetchedData[dependencyURL] = data","                } catch {","                    \/\/ Silently fail for prefetching","                    print(\"Failed to prefetch \\(dependencyURL): \\(error.localizedDescription)\")","                }","            }","        }","    }","    ","    func getPrefetchedData(for url: URL) -> Data? {","        return prefetchedData[url]","    }","}"]},{"text":"Monitoring and Analytics","anchor":"Monitoring-and-Analytics","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Implement performance monitoring to identify bottlenecks:","type":"text"}]},{"syntax":"swift","code":["class PerformanceMonitor {","    private var requestTimings = [String: [TimeInterval]]()","    private let lock = NSLock()","    ","    func recordRequestStart(endpoint: String) -> CFAbsoluteTime {","        return CFAbsoluteTimeGetCurrent()","    }","    ","    func recordRequestEnd(endpoint: String, startTime: CFAbsoluteTime) {","        let duration = CFAbsoluteTimeGetCurrent() - startTime","        ","        lock.lock()","        defer { lock.unlock() }","        ","        if requestTimings[endpoint] == nil {","            requestTimings[endpoint] = [duration]","        } else {","            requestTimings[endpoint]?.append(duration)","        }","        ","        \/\/ Log slow requests","        if duration > 1.0 {","            print(\"⚠️ Slow request to \\(endpoint): \\(String(format: \"%.2f\", duration))s\")","        }","    }","    ","    func getAverageResponseTime(for endpoint: String) -> TimeInterval? {","        lock.lock()","        defer { lock.unlock() }","        ","        guard let timings = requestTimings[endpoint], !timings.isEmpty else {","            return nil","        }","        ","        return timings.reduce(0, +) \/ Double(timings.count)","    }","    ","    func generatePerformanceReport() -> [String: Any] {","        lock.lock()","        defer { lock.unlock() }","        ","        var report = [String: Any]()","        ","        for (endpoint, timings) in requestTimings {","            guard !timings.isEmpty else { continue }","            ","            let avgTime = timings.reduce(0, +) \/ Double(timings.count)","            let maxTime = timings.max() ?? 0","            let minTime = timings.min() ?? 0","            ","            report[endpoint] = [","                \"avg\": avgTime,","                \"min\": minTime,","                \"max\": maxTime,","                \"count\": timings.count","            ]","        }","        ","        return report","    }","}"],"type":"codeListing"},{"text":"Best Practices Summary","anchor":"Best-Practices-Summary","type":"heading","level":2},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Implement comprehensive caching"}]},{"type":"text","text":":"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use memory caching for frequently accessed data"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add persistent caching for larger or less frequently changing data"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Implement conditional requests with ETags"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Optimize network usage"}],"type":"strong"},{"text":":","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Enable compression in requests","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Limit response size with query parameters"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Deduplicate in-flight requests","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Use concurrency effectively","type":"text"}]},{"type":"text","text":":"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Download resources in parallel"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Prioritize user-initiated tasks","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Implement connection pooling","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Implement predictive loading","type":"text"}],"type":"strong"},{"type":"text","text":":"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Prefetch likely-to-be-needed resources","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Load related packages in the background"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Monitor performance","type":"text"}],"type":"strong"},{"text":":","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Track request timings","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Identify slow operations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Generate reports for optimization opportunities"}],"type":"paragraph"}]}]}]}],"type":"orderedList"}]}],"sections":[],"kind":"article","seeAlsoSections":[{"title":"Related Documentation","identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes"],"anchor":"Related-Documentation"},{"generated":true,"title":"Guides","identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security"],"anchor":"Guides"}],"abstract":[{"type":"text","text":"Learn how to optimize your Swift Package Registry API usage for maximum performance."}],"references":{"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","url":"\/documentation\/registry-api\/errorcodes","abstract":[{"text":"Understand how the Swift Package Registry API communicates errors and how to handle them.","type":"text"}],"type":"topic","title":"Error Codes","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Security":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","url":"\/documentation\/registry-api\/security","abstract":[{"text":"Learn how to securely interact with the Swift Package Registry API.","type":"text"}],"type":"topic","title":"Security Best Practices","role":"article"},"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","abstract":[{"type":"text","text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages."}],"role":"collection","kind":"symbol","type":"topic","title":"Registry API","url":"\/documentation\/registryapi"},"doc://com.example.RegistryAPI/documentation/Registry-API/Authentication":{"role":"article","type":"topic","url":"\/documentation\/registry-api\/authentication","abstract":[{"type":"text","text":"Learn how to authenticate with the Swift Package Registry API for accessing private packages and publishing."}],"title":"Authentication","kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication"},"doc://com.example.RegistryAPI/documentation/Registry-API/RateLimiting":{"role":"article","title":"Rate Limiting","abstract":[{"type":"text","text":"Learn about the Swift Package Registry’s rate limiting mechanisms and how to optimize your usage."}],"type":"topic","kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","url":"\/documentation\/registry-api\/ratelimiting"},"doc://com.example.RegistryAPI/documentation/Registry-API/Publishing":{"url":"\/documentation\/registry-api\/publishing","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","type":"topic","kind":"article","title":"Publishing Packages","abstract":[{"type":"text","text":"Learn how to publish your Swift packages to a package registry."}],"role":"article"}}}