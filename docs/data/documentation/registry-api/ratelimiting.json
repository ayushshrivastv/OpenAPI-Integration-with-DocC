{"kind":"article","primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The Swift Package Registry API implements rate limiting to ensure fair usage and system stability. Understanding these limits and implementing proper handling will improve your applicationâ€™s reliability when interacting with the registry.","type":"text"}]},{"type":"heading","level":2,"anchor":"Rate-Limiting-Headers","text":"Rate Limiting Headers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you make requests to the API, the following headers are included in every response:"}]},{"type":"table","rows":[[[{"inlineContent":[{"type":"text","text":"Header"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Description","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Limit"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Maximum number of requests allowed in the current time window"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Remaining"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Number of requests remaining in the current time window","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Reset"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Time when the current rate limit window resets (UTC epoch seconds)"}],"type":"paragraph"}]]],"header":"row"},{"type":"codeListing","syntax":"swift","code":["\/\/ Example: Checking rate limiting headers","func checkRateLimits(from response: HTTPURLResponse) -> RateLimitInfo {","    let limit = Int(response.value(forHTTPHeaderField: \"RateLimit-Limit\") ?? \"60\") ?? 60","    let remaining = Int(response.value(forHTTPHeaderField: \"RateLimit-Remaining\") ?? \"0\") ?? 0","    let resetTime = TimeInterval(response.value(forHTTPHeaderField: \"RateLimit-Reset\") ?? \"0\") ?? 0","    ","    return RateLimitInfo(","        limit: limit, ","        remaining: remaining, ","        resetDate: Date(timeIntervalSince1970: resetTime)","    )","}"]},{"type":"heading","level":2,"anchor":"Rate-Limit-Tiers","text":"Rate Limit Tiers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The API has different rate limit tiers depending on your authentication status:"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tier"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests per Hour"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Description"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Anonymous"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"60"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unauthenticated requests"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Authenticated"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"1,000"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests with a valid user token"}]}]],[[{"type":"paragraph","inlineContent":[{"text":"Service","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"5,000"}]}],[{"type":"paragraph","inlineContent":[{"text":"Requests with a service token","type":"text"}]}]]],"header":"row"},{"type":"heading","level":2,"anchor":"Handling-Rate-Limiting","text":"Handling Rate Limiting"},{"type":"paragraph","inlineContent":[{"text":"When you exceed your rate limit, the API responds with a ","type":"text"},{"type":"codeVoice","code":"429 Too Many Requests"},{"text":" status code and includes a ","type":"text"},{"type":"codeVoice","code":"Retry-After"},{"text":" header indicating how many seconds to wait before retrying.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Example: Rate limit handling with backoff","func makeRegistryRequest(_ request: URLRequest) async throws -> Data {","    let session = URLSession.shared","    ","    do {","        let (data, response) = try await session.data(for: request)","        guard let httpResponse = response as? HTTPURLResponse else {","            throw RegistryError.invalidResponse","        }","        ","        if httpResponse.statusCode == 429 {","            \/\/ We hit a rate limit","            if let retryAfterString = httpResponse.value(forHTTPHeaderField: \"Retry-After\"),","               let retryAfter = TimeInterval(retryAfterString) {","                ","                \/\/ Wait for the specified time before retrying","                try await Task.sleep(nanoseconds: UInt64(retryAfter * 1_000_000_000))","                ","                \/\/ Retry the request","                return try await makeRegistryRequest(request)","            } else {","                throw RegistryError.rateLimitExceeded","            }","        }","        ","        \/\/ Handle other status codes...","        ","        return data","    } catch {","        \/\/ Handle network errors","        throw error","    }","}"]},{"type":"heading","level":2,"anchor":"Best-Practices","text":"Best Practices"},{"type":"heading","level":3,"anchor":"1-Monitor-Your-Usage","text":"1. Monitor Your Usage"},{"type":"paragraph","inlineContent":[{"text":"Always check rate limit headers and keep track of your consumption to avoid hitting limits:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryClient {","    private var rateLimitInfo: RateLimitInfo?","    ","    func updateRateLimitInfo(from response: HTTPURLResponse) {","        rateLimitInfo = checkRateLimits(from: response)","        ","        \/\/ Log when close to limit","        if let info = rateLimitInfo, info.remaining < info.limit * 0.1 {","            print(\"Warning: Rate limit nearly reached. \\(info.remaining) requests remaining until \\(info.resetDate)\")","        }","    }","    ","    \/\/ Other methods...","}"]},{"type":"heading","level":3,"anchor":"2-Implement-Caching","text":"2. Implement Caching"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduce your API calls by caching responses appropriately:"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryClient {","    private var cache = NSCache<NSString, CachedResponse>()","    ","    func fetchPackageMetadata(scope: String, name: String) async throws -> PackageMetadata {","        let cacheKey = \"\\(scope)\/\\(name)\" as NSString","        ","        \/\/ Check cache first","        if let cachedResponse = cache.object(forKey: cacheKey),","           cachedResponse.expirationDate > Date() {","            return cachedResponse.metadata","        }","        ","        \/\/ Make API request","        let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","        let (data, response) = try await URLSession.shared.data(from: url)","        ","        \/\/ Update rate limit info","        if let httpResponse = response as? HTTPURLResponse {","            updateRateLimitInfo(from: httpResponse)","        }","        ","        \/\/ Parse and cache response","        let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","        ","        \/\/ Cache for 5 minutes","        let cachedResponse = CachedResponse(","            metadata: metadata,","            expirationDate: Date().addingTimeInterval(5 * 60)","        )","        cache.setObject(cachedResponse, forKey: cacheKey)","        ","        return metadata","    }","}"]},{"type":"heading","level":3,"anchor":"3-Use-Conditional-Requests","text":"3. Use Conditional Requests"},{"type":"paragraph","inlineContent":[{"text":"When appropriate, use ETag or Last-Modified headers to make conditional requests:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func fetchPackageWithETag(scope: String, name: String) async throws -> PackageMetadata {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","    var request = URLRequest(url: url)","    ","    \/\/ Add ETag if we have it","    if let etag = etagStorage[\"\\(scope)\/\\(name)\"] {","        request.addValue(etag, forHTTPHeaderField: \"If-None-Match\")","    }","    ","    let (data, response) = try await URLSession.shared.data(for: request)","    guard let httpResponse = response as? HTTPURLResponse else {","        throw RegistryError.invalidResponse","    }","    ","    \/\/ Update rate limit info","    updateRateLimitInfo(from: httpResponse)","    ","    \/\/ Store new ETag if present","    if let newETag = httpResponse.value(forHTTPHeaderField: \"ETag\") {","        etagStorage[\"\\(scope)\/\\(name)\"] = newETag","    }","    ","    \/\/ If 304 Not Modified, return cached data","    if httpResponse.statusCode == 304 {","        guard let cachedMetadata = metadataCache[\"\\(scope)\/\\(name)\"] else {","            throw RegistryError.cacheInconsistency","        }","        return cachedMetadata","    }","    ","    \/\/ Process new data","    let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","    metadataCache[\"\\(scope)\/\\(name)\"] = metadata","    return metadata","}"]},{"type":"heading","level":3,"anchor":"4-Batch-Requests-When-Possible","text":"4. Batch Requests When Possible"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of making multiple small requests, batch them when the API supports it:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Instead of fetching packages one by one","func fetchMultiplePackageIdentifiers(query: String) async throws -> [Identifier] {","    \/\/ Use the search endpoint with multiple criteria","    let url = URL(string: \"https:\/\/registry.example.com\/identifiers?query=\\(query)&limit=100\")!","    let (data, response) = try await URLSession.shared.data(from: url)","    ","    if let httpResponse = response as? HTTPURLResponse {","        updateRateLimitInfo(from: httpResponse)","    }","    ","    return try JSONDecoder().decode([Identifier].self, from: data)","}"]},{"type":"heading","level":3,"anchor":"5-Queue-and-Prioritize-Requests","text":"5. Queue and Prioritize Requests"},{"type":"paragraph","inlineContent":[{"text":"When working with many requests, implement a queue system that respects rate limits:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryRequestQueue {","    private var queue = [RegistryRequest]()","    private var isProcessing = false","    ","    func addRequest(_ request: RegistryRequest) {","        queue.append(request)","        processQueue()","    }","    ","    private func processQueue() {","        guard !isProcessing, !queue.isEmpty else { return }","        ","        isProcessing = true","        ","        Task {","            repeat {","                \/\/ Sort queue by priority","                queue.sort { $0.priority > $1.priority }","                ","                \/\/ Take the next request","                let nextRequest = queue.removeFirst()","                ","                do {","                    let _ = try await executeRequest(nextRequest)","                    \/\/ Handle success","                    await nextRequest.completion(.success(()))","                } catch {","                    \/\/ Handle error","                    await nextRequest.completion(.failure(error))","                    ","                    if let registryError = error as? RegistryError, ","                       case .rateLimitExceeded = registryError {","                        \/\/ Wait before continuing if rate limited","                        try? await Task.sleep(nanoseconds: 5_000_000_000)","                    }","                }","            } while !queue.isEmpty","            ","            isProcessing = false","        }","    }","    ","    \/\/ Other methods...","}"]}]}],"identifier":{"url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","interfaceLanguage":"openapi"},"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"sections":[],"abstract":[{"text":"Learn about the Swift Package Registryâ€™s rate limiting mechanisms and how to optimize your usage.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"anchor":"Related-Documentation","title":"Related Documentation"},{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"generated":true,"anchor":"Guides","title":"Guides"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"role":"article","modules":[{"name":"Registry API"}],"roleHeading":"Article","title":"Rate Limiting"},"references":{"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","url":"\/documentation\/registry-api\/errorcodes","abstract":[{"text":"Understand how the Swift Package Registry API communicates errors and how to handle them.","type":"text"}],"type":"topic","title":"Error Codes","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Performance":{"url":"\/documentation\/registry-api\/performance","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","type":"topic","kind":"article","title":"Performance Optimization","abstract":[{"type":"text","text":"Learn how to optimize your Swift Package Registry API usage for maximum performance."}],"role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Authentication":{"url":"\/documentation\/registry-api\/authentication","abstract":[{"type":"text","text":"Learn how to authenticate with the Swift Package Registry API for accessing private packages and publishing."}],"type":"topic","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","title":"Authentication","role":"article","kind":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Security":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","url":"\/documentation\/registry-api\/security","abstract":[{"text":"Learn how to securely interact with the Swift Package Registry API.","type":"text"}],"type":"topic","title":"Security Best Practices","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Publishing":{"url":"\/documentation\/registry-api\/publishing","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","type":"topic","kind":"article","title":"Publishing Packages","abstract":[{"type":"text","text":"Learn how to publish your Swift packages to a package registry."}],"role":"article"},"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","abstract":[{"type":"text","text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages."}],"role":"collection","kind":"symbol","type":"topic","title":"Registry API","url":"\/documentation\/registryapi"}}}