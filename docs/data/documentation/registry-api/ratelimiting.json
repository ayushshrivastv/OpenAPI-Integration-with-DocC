{"kind":"article","primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The Swift Package Registry API implements rate limiting to ensure fair usage and system stability. Understanding these limits and implementing proper handling will improve your application’s reliability when interacting with the registry.","type":"text"}]},{"type":"heading","level":2,"anchor":"Rate-Limiting-Headers","text":"Rate Limiting Headers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you make requests to the API, the following headers are included in every response:"}]},{"type":"table","rows":[[[{"inlineContent":[{"type":"text","text":"Header"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Description","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Limit"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Maximum number of requests allowed in the current time window"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Remaining"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Number of requests remaining in the current time window","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Reset"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Time when the current rate limit window resets (UTC epoch seconds)"}],"type":"paragraph"}]]],"header":"row"},{"type":"codeListing","syntax":"swift","code":["\/\/ Example: Checking rate limiting headers","func checkRateLimits(from response: HTTPURLResponse) -> RateLimitInfo {","    let limit = Int(response.value(forHTTPHeaderField: \"RateLimit-Limit\") ?? \"60\") ?? 60","    let remaining = Int(response.value(forHTTPHeaderField: \"RateLimit-Remaining\") ?? \"0\") ?? 0","    let resetTime = TimeInterval(response.value(forHTTPHeaderField: \"RateLimit-Reset\") ?? \"0\") ?? 0","    ","    return RateLimitInfo(","        limit: limit, ","        remaining: remaining, ","        resetDate: Date(timeIntervalSince1970: resetTime)","    )","}"]},{"type":"heading","level":2,"anchor":"Rate-Limit-Tiers","text":"Rate Limit Tiers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The API has different rate limit tiers depending on your authentication status:"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tier"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests per Hour"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Description"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Anonymous"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"60"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unauthenticated requests"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Authenticated"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"1,000"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests with a valid user token"}]}]],[[{"type":"paragraph","inlineContent":[{"text":"Service","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"5,000"}]}],[{"type":"paragraph","inlineContent":[{"text":"Requests with a service token","type":"text"}]}]]],"header":"row"},{"type":"heading","level":2,"anchor":"Handling-Rate-Limiting","text":"Handling Rate Limiting"},{"type":"paragraph","inlineContent":[{"text":"When you exceed your rate limit, the API responds with a ","type":"text"},{"type":"codeVoice","code":"429 Too Many Requests"},{"text":" status code and includes a ","type":"text"},{"type":"codeVoice","code":"Retry-After"},{"text":" header indicating how many seconds to wait before retrying.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Example: Rate limit handling with backoff","func makeRegistryRequest(_ request: URLRequest) async throws -> Data {","    let session = URLSession.shared","    ","    do {","        let (data, response) = try await session.data(for: request)","        guard let httpResponse = response as? HTTPURLResponse else {","            throw RegistryError.invalidResponse","        }","        ","        if httpResponse.statusCode == 429 {","            \/\/ We hit a rate limit","            if let retryAfterString = httpResponse.value(forHTTPHeaderField: \"Retry-After\"),","               let retryAfter = TimeInterval(retryAfterString) {","                ","                \/\/ Wait for the specified time before retrying","                try await Task.sleep(nanoseconds: UInt64(retryAfter * 1_000_000_000))","                ","                \/\/ Retry the request","                return try await makeRegistryRequest(request)","            } else {","                throw RegistryError.rateLimitExceeded","            }","        }","        ","        \/\/ Handle other status codes...","        ","        return data","    } catch {","        \/\/ Handle network errors","        throw error","    }","}"]},{"type":"heading","level":2,"anchor":"Best-Practices","text":"Best Practices"},{"type":"heading","level":3,"anchor":"1-Monitor-Your-Usage","text":"1. Monitor Your Usage"},{"type":"paragraph","inlineContent":[{"text":"Always check rate limit headers and keep track of your consumption to avoid hitting limits:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryClient {","    private var rateLimitInfo: RateLimitInfo?","    ","    func updateRateLimitInfo(from response: HTTPURLResponse) {","        rateLimitInfo = checkRateLimits(from: response)","        ","        \/\/ Log when close to limit","        if let info = rateLimitInfo, info.remaining < info.limit * 0.1 {","            print(\"Warning: Rate limit nearly reached. \\(info.remaining) requests remaining until \\(info.resetDate)\")","        }","    }","    ","    \/\/ Other methods...","}"]},{"type":"heading","level":3,"anchor":"2-Implement-Caching","text":"2. Implement Caching"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduce your API calls by caching responses appropriately:"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryClient {","    private var cache = NSCache<NSString, CachedResponse>()","    ","    func fetchPackageMetadata(scope: String, name: String) async throws -> PackageMetadata {","        let cacheKey = \"\\(scope)\/\\(name)\" as NSString","        ","        \/\/ Check cache first","        if let cachedResponse = cache.object(forKey: cacheKey),","           cachedResponse.expirationDate > Date() {","            return cachedResponse.metadata","        }","        ","        \/\/ Make API request","        let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","        let (data, response) = try await URLSession.shared.data(from: url)","        ","        \/\/ Update rate limit info","        if let httpResponse = response as? HTTPURLResponse {","            updateRateLimitInfo(from: httpResponse)","        }","        ","        \/\/ Parse and cache response","        let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","        ","        \/\/ Cache for 5 minutes","        let cachedResponse = CachedResponse(","            metadata: metadata,","            expirationDate: Date().addingTimeInterval(5 * 60)","        )","        cache.setObject(cachedResponse, forKey: cacheKey)","        ","        return metadata","    }","}"]},{"type":"heading","level":3,"anchor":"3-Use-Conditional-Requests","text":"3. Use Conditional Requests"},{"type":"paragraph","inlineContent":[{"text":"When appropriate, use ETag or Last-Modified headers to make conditional requests:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func fetchPackageWithETag(scope: String, name: String) async throws -> PackageMetadata {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","    var request = URLRequest(url: url)","    ","    \/\/ Add ETag if we have it","    if let etag = etagStorage[\"\\(scope)\/\\(name)\"] {","        request.addValue(etag, forHTTPHeaderField: \"If-None-Match\")","    }","    ","    let (data, response) = try await URLSession.shared.data(for: request)","    guard let httpResponse = response as? HTTPURLResponse else {","        throw RegistryError.invalidResponse","    }","    ","    \/\/ Update rate limit info","    updateRateLimitInfo(from: httpResponse)","    ","    \/\/ Store new ETag if present","    if let newETag = httpResponse.value(forHTTPHeaderField: \"ETag\") {","        etagStorage[\"\\(scope)\/\\(name)\"] = newETag","    }","    ","    \/\/ If 304 Not Modified, return cached data","    if httpResponse.statusCode == 304 {","        guard let cachedMetadata = metadataCache[\"\\(scope)\/\\(name)\"] else {","            throw RegistryError.cacheInconsistency","        }","        return cachedMetadata","    }","    ","    \/\/ Process new data","    let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","    metadataCache[\"\\(scope)\/\\(name)\"] = metadata","    return metadata","}"]},{"type":"heading","level":3,"anchor":"4-Batch-Requests-When-Possible","text":"4. Batch Requests When Possible"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of making multiple small requests, batch them when the API supports it:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Instead of fetching packages one by one","func fetchMultiplePackageIdentifiers(query: String) async throws -> [Identifier] {","    \/\/ Use the search endpoint with multiple criteria","    let url = URL(string: \"https:\/\/registry.example.com\/identifiers?query=\\(query)&limit=100\")!","    let (data, response) = try await URLSession.shared.data(from: url)","    ","    if let httpResponse = response as? HTTPURLResponse {","        updateRateLimitInfo(from: httpResponse)","    }","    ","    return try JSONDecoder().decode([Identifier].self, from: data)","}"]},{"type":"heading","level":3,"anchor":"5-Queue-and-Prioritize-Requests","text":"5. Queue and Prioritize Requests"},{"type":"paragraph","inlineContent":[{"text":"When working with many requests, implement a queue system that respects rate limits:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class RegistryRequestQueue {","    private var queue = [RegistryRequest]()","    private var isProcessing = false","    ","    func addRequest(_ request: RegistryRequest) {","        queue.append(request)","        processQueue()","    }","    ","    private func processQueue() {","        guard !isProcessing, !queue.isEmpty else { return }","        ","        isProcessing = true","        ","        Task {","            repeat {","                \/\/ Sort queue by priority","                queue.sort { $0.priority > $1.priority }","                ","                \/\/ Take the next request","                let nextRequest = queue.removeFirst()","                ","                do {","                    let _ = try await executeRequest(nextRequest)","                    \/\/ Handle success","                    await nextRequest.completion(.success(()))","                } catch {","                    \/\/ Handle error","                    await nextRequest.completion(.failure(error))","                    ","                    if let registryError = error as? RegistryError, ","                       case .rateLimitExceeded = registryError {","                        \/\/ Wait before continuing if rate limited","                        try? await Task.sleep(nanoseconds: 5_000_000_000)","                    }","                }","            } while !queue.isEmpty","            ","            isProcessing = false","        }","    }","    ","    \/\/ Other methods...","}"]}]}],"identifier":{"url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","interfaceLanguage":"openapi"},"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"sections":[],"abstract":[{"text":"Learn about the Swift Package Registry’s rate limiting mechanisms and how to optimize your usage.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"anchor":"Related-Documentation","title":"Related Documentation"},{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"generated":true,"anchor":"Guides","title":"Guides"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"role":"article","modules":[{"name":"Registry API"}],"roleHeading":"Article","title":"Rate Limiting"},"references":{"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","url":"\/documentation\/registry-api\/errorcodes","abstract":[{"text":"Understand how the Swift Package Registry API communicates errors and how to handle them.","type":"text"}],"type":"topic","title":"Error Codes","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Performance":{"url":"\/documentation\/registry-api\/performance","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","type":"topic","kind":"article","title":"Performance Optimization","abstract":[{"type":"text","text":"Learn how to optimize your Swift Package Registry API usage for maximum performance."}],"role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Authentication":{"url":"\/documentation\/registry-api\/authentication","abstract":[{"type":"text","text":"Learn how to authenticate with the Swift Package Registry API for accessing private packages and publishing."}],"type":"topic","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","title":"Authentication","role":"article","kind":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Security":{"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","url":"\/documentation\/registry-api\/security","abstract":[{"text":"Learn how to securely interact with the Swift Package Registry API.","type":"text"}],"type":"topic","title":"Security Best Practices","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Publishing":{"url":"\/documentation\/registry-api\/publishing","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","type":"topic","kind":"article","title":"Publishing Packages","abstract":[{"type":"text","text":"Learn how to publish your Swift packages to a package registry."}],"role":"article"},"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","abstract":[{"type":"text","text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages."}],"role":"collection","kind":"symbol","type":"topic","title":"Registry API","url":"\/documentation\/registryapi"}}}