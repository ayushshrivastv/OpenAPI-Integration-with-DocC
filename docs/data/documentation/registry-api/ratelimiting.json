{"sections":[],"kind":"article","primaryContentSections":[{"content":[{"type":"heading","anchor":"Overview","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift Package Registry API implements rate limiting to ensure fair usage and system stability. Understanding these limits and implementing proper handling will improve your applicationâ€™s reliability when interacting with the registry."}]},{"type":"heading","anchor":"Rate-Limiting-Headers","text":"Rate Limiting Headers","level":2},{"type":"paragraph","inlineContent":[{"text":"When you make requests to the API, the following headers are included in every response:","type":"text"}]},{"type":"table","header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"text":"Header","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Description"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"RateLimit-Limit"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Maximum number of requests allowed in the current time window"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"RateLimit-Remaining"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Number of requests remaining in the current time window"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"RateLimit-Reset","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"text":"Time when the current rate limit window resets (UTC epoch seconds)","type":"text"}]}]]]},{"type":"codeListing","code":["\/\/ Example: Checking rate limiting headers","func checkRateLimits(from response: HTTPURLResponse) -> RateLimitInfo {","    let limit = Int(response.value(forHTTPHeaderField: \"RateLimit-Limit\") ?? \"60\") ?? 60","    let remaining = Int(response.value(forHTTPHeaderField: \"RateLimit-Remaining\") ?? \"0\") ?? 0","    let resetTime = TimeInterval(response.value(forHTTPHeaderField: \"RateLimit-Reset\") ?? \"0\") ?? 0","    ","    return RateLimitInfo(","        limit: limit, ","        remaining: remaining, ","        resetDate: Date(timeIntervalSince1970: resetTime)","    )","}"],"syntax":"swift"},{"type":"heading","anchor":"Rate-Limit-Tiers","text":"Rate Limit Tiers","level":2},{"type":"paragraph","inlineContent":[{"text":"The API has different rate limit tiers depending on your authentication status:","type":"text"}]},{"type":"table","header":"row","rows":[[[{"inlineContent":[{"text":"Tier","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Requests per Hour"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Description"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Anonymous"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"60"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Unauthenticated requests","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Authenticated"}],"type":"paragraph"}],[{"inlineContent":[{"text":"1,000","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Requests with a valid user token"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Service"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"5,000"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Requests with a service token"}],"type":"paragraph"}]]]},{"type":"heading","anchor":"Handling-Rate-Limiting","text":"Handling Rate Limiting","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you exceed your rate limit, the API responds with a "},{"type":"codeVoice","code":"429 Too Many Requests"},{"type":"text","text":" status code and includes a "},{"type":"codeVoice","code":"Retry-After"},{"type":"text","text":" header indicating how many seconds to wait before retrying."}]},{"type":"codeListing","code":["\/\/ Example: Rate limit handling with backoff","func makeRegistryRequest(_ request: URLRequest) async throws -> Data {","    let session = URLSession.shared","    ","    do {","        let (data, response) = try await session.data(for: request)","        guard let httpResponse = response as? HTTPURLResponse else {","            throw RegistryError.invalidResponse","        }","        ","        if httpResponse.statusCode == 429 {","            \/\/ We hit a rate limit","            if let retryAfterString = httpResponse.value(forHTTPHeaderField: \"Retry-After\"),","               let retryAfter = TimeInterval(retryAfterString) {","                ","                \/\/ Wait for the specified time before retrying","                try await Task.sleep(nanoseconds: UInt64(retryAfter * 1_000_000_000))","                ","                \/\/ Retry the request","                return try await makeRegistryRequest(request)","            } else {","                throw RegistryError.rateLimitExceeded","            }","        }","        ","        \/\/ Handle other status codes...","        ","        return data","    } catch {","        \/\/ Handle network errors","        throw error","    }","}"],"syntax":"swift"},{"type":"heading","anchor":"Best-Practices","text":"Best Practices","level":2},{"type":"heading","anchor":"1-Monitor-Your-Usage","text":"1. Monitor Your Usage","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always check rate limit headers and keep track of your consumption to avoid hitting limits:"}]},{"type":"codeListing","code":["class RegistryClient {","    private var rateLimitInfo: RateLimitInfo?","    ","    func updateRateLimitInfo(from response: HTTPURLResponse) {","        rateLimitInfo = checkRateLimits(from: response)","        ","        \/\/ Log when close to limit","        if let info = rateLimitInfo, info.remaining < info.limit * 0.1 {","            print(\"Warning: Rate limit nearly reached. \\(info.remaining) requests remaining until \\(info.resetDate)\")","        }","    }","    ","    \/\/ Other methods...","}"],"syntax":"swift"},{"type":"heading","anchor":"2-Implement-Caching","text":"2. Implement Caching","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduce your API calls by caching responses appropriately:"}]},{"type":"codeListing","code":["class RegistryClient {","    private var cache = NSCache<NSString, CachedResponse>()","    ","    func fetchPackageMetadata(scope: String, name: String) async throws -> PackageMetadata {","        let cacheKey = \"\\(scope)\/\\(name)\" as NSString","        ","        \/\/ Check cache first","        if let cachedResponse = cache.object(forKey: cacheKey),","           cachedResponse.expirationDate > Date() {","            return cachedResponse.metadata","        }","        ","        \/\/ Make API request","        let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","        let (data, response) = try await URLSession.shared.data(from: url)","        ","        \/\/ Update rate limit info","        if let httpResponse = response as? HTTPURLResponse {","            updateRateLimitInfo(from: httpResponse)","        }","        ","        \/\/ Parse and cache response","        let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","        ","        \/\/ Cache for 5 minutes","        let cachedResponse = CachedResponse(","            metadata: metadata,","            expirationDate: Date().addingTimeInterval(5 * 60)","        )","        cache.setObject(cachedResponse, forKey: cacheKey)","        ","        return metadata","    }","}"],"syntax":"swift"},{"type":"heading","anchor":"3-Use-Conditional-Requests","text":"3. Use Conditional Requests","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"When appropriate, use ETag or Last-Modified headers to make conditional requests:"}]},{"type":"codeListing","code":["func fetchPackageWithETag(scope: String, name: String) async throws -> PackageMetadata {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","    var request = URLRequest(url: url)","    ","    \/\/ Add ETag if we have it","    if let etag = etagStorage[\"\\(scope)\/\\(name)\"] {","        request.addValue(etag, forHTTPHeaderField: \"If-None-Match\")","    }","    ","    let (data, response) = try await URLSession.shared.data(for: request)","    guard let httpResponse = response as? HTTPURLResponse else {","        throw RegistryError.invalidResponse","    }","    ","    \/\/ Update rate limit info","    updateRateLimitInfo(from: httpResponse)","    ","    \/\/ Store new ETag if present","    if let newETag = httpResponse.value(forHTTPHeaderField: \"ETag\") {","        etagStorage[\"\\(scope)\/\\(name)\"] = newETag","    }","    ","    \/\/ If 304 Not Modified, return cached data","    if httpResponse.statusCode == 304 {","        guard let cachedMetadata = metadataCache[\"\\(scope)\/\\(name)\"] else {","            throw RegistryError.cacheInconsistency","        }","        return cachedMetadata","    }","    ","    \/\/ Process new data","    let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","    metadataCache[\"\\(scope)\/\\(name)\"] = metadata","    return metadata","}"],"syntax":"swift"},{"type":"heading","anchor":"4-Batch-Requests-When-Possible","text":"4. Batch Requests When Possible","level":3},{"type":"paragraph","inlineContent":[{"text":"Instead of making multiple small requests, batch them when the API supports it:","type":"text"}]},{"type":"codeListing","code":["\/\/ Instead of fetching packages one by one","func fetchMultiplePackageIdentifiers(query: String) async throws -> [Identifier] {","    \/\/ Use the search endpoint with multiple criteria","    let url = URL(string: \"https:\/\/registry.example.com\/identifiers?query=\\(query)&limit=100\")!","    let (data, response) = try await URLSession.shared.data(from: url)","    ","    if let httpResponse = response as? HTTPURLResponse {","        updateRateLimitInfo(from: httpResponse)","    }","    ","    return try JSONDecoder().decode([Identifier].self, from: data)","}"],"syntax":"swift"},{"type":"heading","anchor":"5-Queue-and-Prioritize-Requests","text":"5. Queue and Prioritize Requests","level":3},{"type":"paragraph","inlineContent":[{"text":"When working with many requests, implement a queue system that respects rate limits:","type":"text"}]},{"type":"codeListing","code":["class RegistryRequestQueue {","    private var queue = [RegistryRequest]()","    private var isProcessing = false","    ","    func addRequest(_ request: RegistryRequest) {","        queue.append(request)","        processQueue()","    }","    ","    private func processQueue() {","        guard !isProcessing, !queue.isEmpty else { return }","        ","        isProcessing = true","        ","        Task {","            repeat {","                \/\/ Sort queue by priority","                queue.sort { $0.priority > $1.priority }","                ","                \/\/ Take the next request","                let nextRequest = queue.removeFirst()","                ","                do {","                    let _ = try await executeRequest(nextRequest)","                    \/\/ Handle success","                    await nextRequest.completion(.success(()))","                } catch {","                    \/\/ Handle error","                    await nextRequest.completion(.failure(error))","                    ","                    if let registryError = error as? RegistryError, ","                       case .rateLimitExceeded = registryError {","                        \/\/ Wait before continuing if rate limited","                        try? await Task.sleep(nanoseconds: 5_000_000_000)","                    }","                }","            } while !queue.isEmpty","            ","            isProcessing = false","        }","    }","    ","    \/\/ Other methods...","}"],"syntax":"swift"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"text":"Learn about the Swift Package Registryâ€™s rate limiting mechanisms and how to optimize your usage.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"title":"Best Practices","generated":true,"anchor":"Best-Practices"}],"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"identifier":{"interfaceLanguage":"openapi","url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting"},"metadata":{"title":"Rate Limiting","modules":[{"name":"RegistryAPI"}],"role":"article","roleHeading":"Article"},"references":{"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"title":"RegistryAPI","kind":"symbol","url":"\/documentation\/registryapi","abstract":[{"text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages.","type":"text"}],"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","type":"topic","role":"collection"},"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"abstract":[{"type":"text","text":"Understand how the Swift Package Registry API communicates errors and how to handle them."}],"type":"topic","kind":"article","url":"\/documentation\/registry-api\/errorcodes","role":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","title":"Error Codes"},"doc://com.example.RegistryAPI/documentation/Registry-API/Security":{"role":"article","url":"\/documentation\/registry-api\/security","type":"topic","abstract":[{"type":"text","text":"Learn how to securely interact with the Swift Package Registry API."}],"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","title":"Security Best Practices"},"doc://com.example.RegistryAPI/documentation/Registry-API/Performance":{"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","abstract":[{"text":"Learn how to optimize your Swift Package Registry API usage for maximum performance.","type":"text"}],"url":"\/documentation\/registry-api\/performance","kind":"article","type":"topic","role":"article","title":"Performance Optimization"}}}