{"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","interfaceLanguage":"openapi"},"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"seeAlsoSections":[{"title":"Related Documentation","identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"anchor":"Related-Documentation"},{"generated":true,"title":"Guides","identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"anchor":"Guides"}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The Swift Package Registry API implements rate limiting to ensure fair usage and system stability. Understanding these limits and implementing proper handling will improve your applicationâ€™s reliability when interacting with the registry.","type":"text"}]},{"text":"Rate Limiting Headers","anchor":"Rate-Limiting-Headers","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"When you make requests to the API, the following headers are included in every response:"}],"type":"paragraph"},{"header":"row","rows":[[[{"inlineContent":[{"type":"text","text":"Header"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Description"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Limit"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Maximum number of requests allowed in the current time window"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Remaining"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Number of requests remaining in the current time window","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"RateLimit-Reset"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Time when the current rate limit window resets (UTC epoch seconds)"}],"type":"paragraph"}]]],"type":"table"},{"type":"codeListing","code":["\/\/ Example: Checking rate limiting headers","func checkRateLimits(from response: HTTPURLResponse) -> RateLimitInfo {","    let limit = Int(response.value(forHTTPHeaderField: \"RateLimit-Limit\") ?? \"60\") ?? 60","    let remaining = Int(response.value(forHTTPHeaderField: \"RateLimit-Remaining\") ?? \"0\") ?? 0","    let resetTime = TimeInterval(response.value(forHTTPHeaderField: \"RateLimit-Reset\") ?? \"0\") ?? 0","    ","    return RateLimitInfo(","        limit: limit, ","        remaining: remaining, ","        resetDate: Date(timeIntervalSince1970: resetTime)","    )","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Rate Limit Tiers","anchor":"Rate-Limit-Tiers"},{"type":"paragraph","inlineContent":[{"text":"The API has different rate limit tiers depending on your authentication status:","type":"text"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tier"}]}],[{"type":"paragraph","inlineContent":[{"text":"Requests per Hour","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"Description","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Anonymous"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"60"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unauthenticated requests"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Authenticated"}]}],[{"type":"paragraph","inlineContent":[{"text":"1,000","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests with a valid user token"}]}]],[[{"type":"paragraph","inlineContent":[{"text":"Service","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"5,000"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requests with a service token"}]}]]],"header":"row"},{"type":"heading","level":2,"text":"Handling Rate Limiting","anchor":"Handling-Rate-Limiting"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you exceed your rate limit, the API responds with a "},{"type":"codeVoice","code":"429 Too Many Requests"},{"type":"text","text":" status code and includes a "},{"type":"codeVoice","code":"Retry-After"},{"type":"text","text":" header indicating how many seconds to wait before retrying."}]},{"type":"codeListing","code":["\/\/ Example: Rate limit handling with backoff","func makeRegistryRequest(_ request: URLRequest) async throws -> Data {","    let session = URLSession.shared","    ","    do {","        let (data, response) = try await session.data(for: request)","        guard let httpResponse = response as? HTTPURLResponse else {","            throw RegistryError.invalidResponse","        }","        ","        if httpResponse.statusCode == 429 {","            \/\/ We hit a rate limit","            if let retryAfterString = httpResponse.value(forHTTPHeaderField: \"Retry-After\"),","               let retryAfter = TimeInterval(retryAfterString) {","                ","                \/\/ Wait for the specified time before retrying","                try await Task.sleep(nanoseconds: UInt64(retryAfter * 1_000_000_000))","                ","                \/\/ Retry the request","                return try await makeRegistryRequest(request)","            } else {","                throw RegistryError.rateLimitExceeded","            }","        }","        ","        \/\/ Handle other status codes...","        ","        return data","    } catch {","        \/\/ Handle network errors","        throw error","    }","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Best Practices","anchor":"Best-Practices"},{"type":"heading","level":3,"text":"1. Monitor Your Usage","anchor":"1-Monitor-Your-Usage"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always check rate limit headers and keep track of your consumption to avoid hitting limits:"}]},{"type":"codeListing","code":["class RegistryClient {","    private var rateLimitInfo: RateLimitInfo?","    ","    func updateRateLimitInfo(from response: HTTPURLResponse) {","        rateLimitInfo = checkRateLimits(from: response)","        ","        \/\/ Log when close to limit","        if let info = rateLimitInfo, info.remaining < info.limit * 0.1 {","            print(\"Warning: Rate limit nearly reached. \\(info.remaining) requests remaining until \\(info.resetDate)\")","        }","    }","    ","    \/\/ Other methods...","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"2. Implement Caching","anchor":"2-Implement-Caching"},{"type":"paragraph","inlineContent":[{"text":"Reduce your API calls by caching responses appropriately:","type":"text"}]},{"type":"codeListing","code":["class RegistryClient {","    private var cache = NSCache<NSString, CachedResponse>()","    ","    func fetchPackageMetadata(scope: String, name: String) async throws -> PackageMetadata {","        let cacheKey = \"\\(scope)\/\\(name)\" as NSString","        ","        \/\/ Check cache first","        if let cachedResponse = cache.object(forKey: cacheKey),","           cachedResponse.expirationDate > Date() {","            return cachedResponse.metadata","        }","        ","        \/\/ Make API request","        let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","        let (data, response) = try await URLSession.shared.data(from: url)","        ","        \/\/ Update rate limit info","        if let httpResponse = response as? HTTPURLResponse {","            updateRateLimitInfo(from: httpResponse)","        }","        ","        \/\/ Parse and cache response","        let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","        ","        \/\/ Cache for 5 minutes","        let cachedResponse = CachedResponse(","            metadata: metadata,","            expirationDate: Date().addingTimeInterval(5 * 60)","        )","        cache.setObject(cachedResponse, forKey: cacheKey)","        ","        return metadata","    }","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"3. Use Conditional Requests","anchor":"3-Use-Conditional-Requests"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When appropriate, use ETag or Last-Modified headers to make conditional requests:"}]},{"type":"codeListing","code":["func fetchPackageWithETag(scope: String, name: String) async throws -> PackageMetadata {","    let url = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\")!","    var request = URLRequest(url: url)","    ","    \/\/ Add ETag if we have it","    if let etag = etagStorage[\"\\(scope)\/\\(name)\"] {","        request.addValue(etag, forHTTPHeaderField: \"If-None-Match\")","    }","    ","    let (data, response) = try await URLSession.shared.data(for: request)","    guard let httpResponse = response as? HTTPURLResponse else {","        throw RegistryError.invalidResponse","    }","    ","    \/\/ Update rate limit info","    updateRateLimitInfo(from: httpResponse)","    ","    \/\/ Store new ETag if present","    if let newETag = httpResponse.value(forHTTPHeaderField: \"ETag\") {","        etagStorage[\"\\(scope)\/\\(name)\"] = newETag","    }","    ","    \/\/ If 304 Not Modified, return cached data","    if httpResponse.statusCode == 304 {","        guard let cachedMetadata = metadataCache[\"\\(scope)\/\\(name)\"] else {","            throw RegistryError.cacheInconsistency","        }","        return cachedMetadata","    }","    ","    \/\/ Process new data","    let metadata = try JSONDecoder().decode(PackageMetadata.self, from: data)","    metadataCache[\"\\(scope)\/\\(name)\"] = metadata","    return metadata","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"4. Batch Requests When Possible","anchor":"4-Batch-Requests-When-Possible"},{"type":"paragraph","inlineContent":[{"text":"Instead of making multiple small requests, batch them when the API supports it:","type":"text"}]},{"type":"codeListing","code":["\/\/ Instead of fetching packages one by one","func fetchMultiplePackageIdentifiers(query: String) async throws -> [Identifier] {","    \/\/ Use the search endpoint with multiple criteria","    let url = URL(string: \"https:\/\/registry.example.com\/identifiers?query=\\(query)&limit=100\")!","    let (data, response) = try await URLSession.shared.data(from: url)","    ","    if let httpResponse = response as? HTTPURLResponse {","        updateRateLimitInfo(from: httpResponse)","    }","    ","    return try JSONDecoder().decode([Identifier].self, from: data)","}"],"syntax":"swift"},{"type":"heading","level":3,"text":"5. Queue and Prioritize Requests","anchor":"5-Queue-and-Prioritize-Requests"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When working with many requests, implement a queue system that respects rate limits:"}]},{"code":["class RegistryRequestQueue {","    private var queue = [RegistryRequest]()","    private var isProcessing = false","    ","    func addRequest(_ request: RegistryRequest) {","        queue.append(request)","        processQueue()","    }","    ","    private func processQueue() {","        guard !isProcessing, !queue.isEmpty else { return }","        ","        isProcessing = true","        ","        Task {","            repeat {","                \/\/ Sort queue by priority","                queue.sort { $0.priority > $1.priority }","                ","                \/\/ Take the next request","                let nextRequest = queue.removeFirst()","                ","                do {","                    let _ = try await executeRequest(nextRequest)","                    \/\/ Handle success","                    await nextRequest.completion(.success(()))","                } catch {","                    \/\/ Handle error","                    await nextRequest.completion(.failure(error))","                    ","                    if let registryError = error as? RegistryError, ","                       case .rateLimitExceeded = registryError {","                        \/\/ Wait before continuing if rate limited","                        try? await Task.sleep(nanoseconds: 5_000_000_000)","                    }","                }","            } while !queue.isEmpty","            ","            isProcessing = false","        }","    }","    ","    \/\/ Other methods...","}"],"type":"codeListing","syntax":"swift"}]}],"metadata":{"roleHeading":"Article","title":"Rate Limiting","modules":[{"name":"Registry API"}],"role":"article"},"sections":[],"kind":"article","abstract":[{"type":"text","text":"Learn about the Swift Package Registryâ€™s rate limiting mechanisms and how to optimize your usage."}],"references":{"doc://com.example.RegistryAPI/documentation/Registry-API/Security":{"role":"article","type":"topic","abstract":[{"text":"Learn how to securely interact with the Swift Package Registry API.","type":"text"}],"url":"\/documentation\/registry-api\/security","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","kind":"article","title":"Security Best Practices"},"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"url":"\/documentation\/registryapi","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","title":"Registry API","kind":"symbol","role":"collection","abstract":[{"type":"text","text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages."}],"type":"topic"},"doc://com.example.RegistryAPI/documentation/Registry-API/Authentication":{"type":"topic","title":"Authentication","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","kind":"article","role":"article","url":"\/documentation\/registry-api\/authentication","abstract":[{"type":"text","text":"Learn how to authenticate with the Swift Package Registry API for accessing private packages and publishing."}]},"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"abstract":[{"type":"text","text":"Understand how the Swift Package Registry API communicates errors and how to handle them."}],"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","url":"\/documentation\/registry-api\/errorcodes","title":"Error Codes","type":"topic","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Performance":{"title":"Performance Optimization","kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","url":"\/documentation\/registry-api\/performance","abstract":[{"type":"text","text":"Learn how to optimize your Swift Package Registry API usage for maximum performance."}],"type":"topic","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Publishing":{"title":"Publishing Packages","type":"topic","kind":"article","abstract":[{"text":"Learn how to publish your Swift packages to a package registry.","type":"text"}],"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","role":"article","url":"\/documentation\/registry-api\/publishing"}}}