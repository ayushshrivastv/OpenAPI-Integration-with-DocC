{"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Security is a critical aspect of package management. This guide covers best practices for securely interacting with the Swift Package Registry API, protecting sensitive information, and verifying package authenticity."}],"type":"paragraph"},{"text":"Secure Authentication","anchor":"Secure-Authentication","level":2,"type":"heading"},{"text":"Token Management","anchor":"Token-Management","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"When working with authentication tokens:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Never hardcode tokens","type":"text"}],"type":"strong"},{"text":" in your application source code","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use environment variables, secure storage, or a secrets management solution"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Rotate tokens regularly following the principle of least privilege","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Set appropriate token expiration times"}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["\/\/ ❌ INCORRECT: Hardcoded token","let apiToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"","","\/\/ ✅ BETTER: Load from secure storage","let apiToken = try KeychainManager.getToken(forService: \"registry-api\")","","\/\/ ✅ BEST: Use a token provider with automatic rotation","let apiToken = try await TokenProvider.shared.getValidToken()"],"syntax":"swift","type":"codeListing"},{"text":"Secure Token Storage","anchor":"Secure-Token-Storage","level":3,"type":"heading"},{"inlineContent":[{"text":"Store your tokens securely using platform-appropriate mechanisms:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Example: Secure token storage using keychain on Apple platforms","class KeychainTokenStorage: TokenStorage {","    func saveToken(_ token: String, forService service: String) throws {","        let query: [String: Any] = [","            kSecClass as String: kSecClassGenericPassword,","            kSecAttrService as String: service,","            kSecAttrAccount as String: \"api-token\",","            kSecValueData as String: Data(token.utf8),","            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly","        ]","        ","        \/\/ Delete any existing token","        SecItemDelete(query as CFDictionary)","        ","        \/\/ Save the new token","        let status = SecItemAdd(query as CFDictionary, nil)","        guard status == errSecSuccess else {","            throw TokenStorageError.saveFailed(status)","        }","    }","    ","    func getToken(forService service: String) throws -> String {","        let query: [String: Any] = [","            kSecClass as String: kSecClassGenericPassword,","            kSecAttrService as String: service,","            kSecAttrAccount as String: \"api-token\",","            kSecReturnData as String: true,","            kSecMatchLimit as String: kSecMatchLimitOne","        ]","        ","        var result: AnyObject?","        let status = SecItemCopyMatching(query as CFDictionary, &result)","        ","        guard status == errSecSuccess else {","            throw TokenStorageError.retrievalFailed(status)","        }","        ","        guard let tokenData = result as? Data,","              let token = String(data: tokenData, encoding: .utf8) else {","            throw TokenStorageError.invalidData","        }","        ","        return token","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Package Integrity Verification","anchor":"Package-Integrity-Verification","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Always verify package integrity using the provided checksums:"}],"type":"paragraph"},{"code":["\/\/ Example: Verify package checksum","func verifyPackageIntegrity(packageData: Data, expectedChecksum: String) throws -> Bool {","    \/\/ Calculate the SHA-256 hash of the package data","    let computedHash = SHA256.hash(data: packageData)","    let computedChecksum = computedHash.compactMap { String(format: \"%02x\", $0) }.joined()","    ","    \/\/ Compare with the expected checksum (case-insensitive)","    return computedChecksum.lowercased() == expectedChecksum.lowercased()","}","","\/\/ Usage example","func downloadAndVerifyPackage(scope: String, name: String, version: String) async throws -> Data {","    \/\/ 1. Get package metadata with checksum information","    let metadataURL = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\/\\(version)\")!","    let (metadataData, _) = try await URLSession.shared.data(from: metadataURL)","    let release = try JSONDecoder().decode(ReleaseResource.self, from: metadataData)","    ","    \/\/ 2. Find the source archive resource and its checksum","    guard let sourceArchive = release.resources.first(where: { $0.name == \"source-archive\" }),","          let checksum = sourceArchive.checksum else {","        throw VerificationError.missingChecksumInfo","    }","    ","    \/\/ 3. Download the package","    let packageURL = URL(string: \"https:\/\/registry.example.com\/\\(scope)\/\\(name)\/\\(version).zip\")!","    let (packageData, _) = try await URLSession.shared.data(from: packageURL)","    ","    \/\/ 4. Verify the integrity","    guard try verifyPackageIntegrity(packageData: packageData, expectedChecksum: checksum) else {","        throw VerificationError.checksumMismatch","    }","    ","    return packageData","}"],"syntax":"swift","type":"codeListing"},{"text":"Transport Security","anchor":"Transport-Security","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Always use secure connections when communicating with the registry:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Ensure your URL connections use HTTPS"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Verify TLS certificates"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enable certificate pinning for critical applications"}]}]}],"type":"unorderedList"},{"code":["\/\/ Example: URL Session configuration with certificate pinning","func createSecureURLSession() -> URLSession {","    let configuration = URLSessionConfiguration.default","    ","    \/\/ Ensure only HTTPS connections are allowed","    configuration.tlsMinimumSupportedProtocolVersion = .TLSv12","    ","    \/\/ Create a delegate for certificate pinning","    let delegate = CertificatePinningDelegate()","    ","    return URLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)","}","","class CertificatePinningDelegate: NSObject, URLSessionDelegate {","    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, ","                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {","        ","        guard let serverTrust = challenge.protectionSpace.serverTrust,","              challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,","              challenge.protectionSpace.host.hasSuffix(\"registry.example.com\") else {","            \/\/ Reject invalid challenges","            completionHandler(.cancelAuthenticationChallenge, nil)","            return","        }","        ","        \/\/ Get the server's certificate data","        let serverCertificatesData = certificateData(for: serverTrust)","        ","        \/\/ Get the pinned certificate data","        guard let pinnedCertificateData = loadPinnedCertificateData() else {","            completionHandler(.cancelAuthenticationChallenge, nil)","            return","        }","        ","        \/\/ Compare certificates","        if serverCertificatesData.contains(pinnedCertificateData) {","            \/\/ Certificate matched, proceed with connection","            let credential = URLCredential(trust: serverTrust)","            completionHandler(.useCredential, credential)","        } else {","            \/\/ Certificate mismatch, cancel connection","            completionHandler(.cancelAuthenticationChallenge, nil)","        }","    }","    ","    \/\/ Helper methods...","}"],"syntax":"swift","type":"codeListing"},{"text":"Secure Dependency Resolution","anchor":"Secure-Dependency-Resolution","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Follow these guidelines when resolving package dependencies:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Define exact versions"}]},{"type":"text","text":" when possible to prevent unexpected changes"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Use package checksums"}]},{"type":"text","text":" to validate package integrity during resolution"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Lock dependencies","type":"text"}]},{"type":"text","text":" in your Package.resolved file"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Audit dependencies","type":"text"}]},{"type":"text","text":" regularly for vulnerabilities"}],"type":"paragraph"}]}],"type":"orderedList"},{"code":["\/\/ Example: Package.swift with pinned dependencies","dependencies: [","    .package(","        url: \"https:\/\/github.com\/apple\/swift-algorithms\",","        exact: \"1.0.0\"  \/\/ Pin to exact version","    ),","    .package(","        url: \"https:\/\/github.com\/apple\/swift-collections\",","        revision: \"a281e8b846a354fca484a08abbc657dfe39c9b1c\"  \/\/ Pin to specific commit","    )","]"],"syntax":"swift","type":"codeListing"},{"text":"Content Security","anchor":"Content-Security","level":2,"type":"heading"},{"text":"XSS Protection","anchor":"XSS-Protection","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"When displaying package metadata or README content in your application:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Always sanitize content before rendering"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Use a secure rendering library that handles escaping"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider Content Security Policy (CSP) for web applications"}]}]}],"type":"orderedList"},{"code":["\/\/ Example: Content sanitization for package metadata","func sanitizeHTMLContent(_ html: String) -> String {","    \/\/ Use a proper HTML sanitizer library here","    \/\/ This is a simplified example","    let disallowedTags = [\"script\", \"iframe\", \"object\", \"embed\"]","    ","    var sanitized = html","    for tag in disallowedTags {","        let openTagPattern = \"<\\(tag)[^>]*>\"","        let closeTagPattern = \"<\/\\(tag)>\"","        ","        sanitized = sanitized.replacingOccurrences(of: openTagPattern, ","                                                  with: \"\", ","                                                  options: .regularExpression)","        sanitized = sanitized.replacingOccurrences(of: closeTagPattern, ","                                                  with: \"\", ","                                                  options: .regularExpression)","    }","    ","    return sanitized","}"],"syntax":"swift","type":"codeListing"},{"text":"Input Validation","anchor":"Input-Validation","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Always validate input parameters before sending them to the API:"}],"type":"paragraph"},{"code":["\/\/ Example: Parameter validation","func validatePackageParameters(scope: String, name: String, version: String?) throws {","    \/\/ Validate scope","    guard scope.range(of: \"^[a-zA-Z0-9][-a-zA-Z0-9_.]*$\", options: .regularExpression) != nil else {","        throw ValidationError.invalidScope","    }","    ","    \/\/ Validate name","    guard name.range(of: \"^[a-zA-Z0-9][-a-zA-Z0-9_.]*$\", options: .regularExpression) != nil else {","        throw ValidationError.invalidName","    }","    ","    \/\/ Validate version if provided","    if let version = version {","        guard version.range(of: \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\", options: .regularExpression) != nil else {","            throw ValidationError.invalidVersion","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Additional Security Measures","anchor":"Additional-Security-Measures","level":2,"type":"heading"},{"text":"API Key Rotation","anchor":"API-Key-Rotation","level":3,"type":"heading"},{"inlineContent":[{"text":"Implement regular key rotation to minimize risk:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Example: Token rotation schedule","class TokenRotationManager {","    private let tokenStorage: TokenStorage","    private let tokenProvider: TokenProvider","    ","    \/\/ Rotate tokens every 30 days","    private let rotationInterval: TimeInterval = 30 * 24 * 60 * 60","    ","    func scheduleRotation() {","        \/\/ Check when the current token was created","        let currentTokenCreationDate = tokenStorage.getTokenCreationDate()","        ","        \/\/ Calculate time until next rotation","        let timeUntilRotation = max(0, ","            (currentTokenCreationDate.addingTimeInterval(rotationInterval).timeIntervalSince1970 - ","             Date().timeIntervalSince1970))","        ","        \/\/ Schedule rotation","        DispatchQueue.global().asyncAfter(deadline: .now() + timeUntilRotation) { [weak self] in","            self?.rotateToken()","        }","    }","    ","    private func rotateToken() {","        do {","            \/\/ Generate new token","            let newToken = try tokenProvider.generateNewToken()","            ","            \/\/ Save the new token","            try tokenStorage.saveToken(newToken)","            ","            \/\/ Revoke the old token","            try tokenProvider.revokeToken(tokenStorage.getOldToken())","            ","            \/\/ Schedule the next rotation","            scheduleRotation()","        } catch {","            \/\/ Handle rotation failure","            \/\/ Log error and retry after a short delay","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"text":"Logging and Monitoring","anchor":"Logging-and-Monitoring","level":3,"type":"heading"},{"inlineContent":[{"text":"Implement secure logging practices:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Never log sensitive information such as tokens or private package data","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Use structured logging for easy analysis","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement monitoring for unusual access patterns","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["\/\/ Example: Secure logging","enum LogLevel: String {","    case debug, info, warning, error","}","","class SecureLogger {","    static func log(_ message: String, level: LogLevel = .info, sensitiveData: Bool = false) {","        \/\/ Don't log sensitive data in production","        #if DEBUG","        let logEntry = \"[\\(level.rawValue.uppercased())] \\(Date()): \\(message)\"","        print(logEntry)","        #else","        if !sensitiveData {","            let logEntry = \"[\\(level.rawValue.uppercased())] \\(Date()): \\(message)\"","            print(logEntry)","            \/\/ In a real implementation, send to logging service","        }","        #endif","    }","    ","    static func logAPIRequest(endpoint: String, statusCode: Int?, error: Error?) {","        var message = \"API Request: \\(endpoint)\"","        ","        if let statusCode = statusCode {","            message += \", Status: \\(statusCode)\"","        }","        ","        if let error = error {","            message += \", Error: \\(error.localizedDescription)\"","        }","        ","        log(message)","    }","}"],"syntax":"swift","type":"codeListing"}]}],"kind":"article","abstract":[{"type":"text","text":"Learn how to securely interact with the Swift Package Registry API."}],"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"url":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Security","interfaceLanguage":"openapi"},"seeAlsoSections":[{"identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes"],"title":"Related Documentation","anchor":"Related-Documentation"},{"anchor":"Guides","identifiers":["doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting","doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance"],"title":"Guides","generated":true}],"metadata":{"title":"Security Best Practices","roleHeading":"Article","modules":[{"name":"Registry API"}],"role":"article"},"sections":[],"hierarchy":{"paths":[["doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI"]]},"references":{"doc://com.example.RegistryAPI/documentation/RegistryAPI":{"url":"\/documentation\/registryapi","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/RegistryAPI","title":"Registry API","kind":"symbol","role":"collection","abstract":[{"type":"text","text":"Interact with Swift packages through a standardized API for publishing, discovering, and retrieving packages."}],"type":"topic"},"doc://com.example.RegistryAPI/documentation/Registry-API/Publishing":{"title":"Publishing Packages","type":"topic","kind":"article","abstract":[{"text":"Learn how to publish your Swift packages to a package registry.","type":"text"}],"identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Publishing","role":"article","url":"\/documentation\/registry-api\/publishing"},"doc://com.example.RegistryAPI/documentation/Registry-API/ErrorCodes":{"abstract":[{"type":"text","text":"Understand how the Swift Package Registry API communicates errors and how to handle them."}],"kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/ErrorCodes","url":"\/documentation\/registry-api\/errorcodes","title":"Error Codes","type":"topic","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/RateLimiting":{"role":"article","url":"\/documentation\/registry-api\/ratelimiting","abstract":[{"type":"text","text":"Learn about the Swift Package Registry’s rate limiting mechanisms and how to optimize your usage."}],"kind":"article","title":"Rate Limiting","type":"topic","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/RateLimiting"},"doc://com.example.RegistryAPI/documentation/Registry-API/Performance":{"title":"Performance Optimization","kind":"article","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Performance","url":"\/documentation\/registry-api\/performance","abstract":[{"type":"text","text":"Learn how to optimize your Swift Package Registry API usage for maximum performance."}],"type":"topic","role":"article"},"doc://com.example.RegistryAPI/documentation/Registry-API/Authentication":{"type":"topic","title":"Authentication","identifier":"doc:\/\/com.example.RegistryAPI\/documentation\/Registry-API\/Authentication","kind":"article","role":"article","url":"\/documentation\/registry-api\/authentication","abstract":[{"type":"text","text":"Learn how to authenticate with the Swift Package Registry API for accessing private packages and publishing."}]}}}