import Foundation
import OpenAPI

/// Provides integration with SwiftOpenAPIGenerator
public struct SwiftOpenAPIIntegration {
    /// The configuration for the SwiftOpenAPIGenerator integration
    private let config: Configuration

    /// Creates a new SwiftOpenAPIGenerator integration
    /// - Parameter config: The configuration for the integration
    public init(config: Configuration = .default) {
        self.config = config
    }

    /// Configuration for the SwiftOpenAPIGenerator integration
    public struct Configuration {
        /// The format to use for generated Swift types
        public let typeFormat: TypeFormat
        /// Whether to include documentation comments in the generated code
        public let includeDocComments: Bool
        /// Whether to include examples in the generated code
        public let includeExamples: Bool

        /// Creates a new configuration
        /// - Parameters:
        ///   - typeFormat: The format to use for generated Swift types
        ///   - includeDocComments: Whether to include documentation comments in the generated code
        ///   - includeExamples: Whether to include examples in the generated code
        public init(typeFormat: TypeFormat, includeDocComments: Bool, includeExamples: Bool) {
            self.typeFormat = typeFormat
            self.includeDocComments = includeDocComments
            self.includeExamples = includeExamples
        }

        /// The default configuration
        public static let `default` = Configuration(
            typeFormat: .structs,
            includeDocComments: true,
            includeExamples: true
        )
    }

    /// The format to use for generated Swift types
    public enum TypeFormat {
        /// Generate Swift structs
        case structs
        /// Generate Swift classes
        case classes
        /// Generate Swift enums for discriminated types
        case enumsForDiscriminator
    }

    /// Generates documentation for the Swift types that would be generated by SwiftOpenAPIGenerator
    /// - Parameter document: The OpenAPI document to generate documentation for
    /// - Returns: A string containing the documentation for the Swift types
    public func generateTypeMappingDocumentation(for document: Document) -> String {
        var documentation = "# Swift Types Mapping\n\n"
        documentation += "This document shows how the OpenAPI schemas would be mapped to Swift types using SwiftOpenAPIGenerator.\n\n"

        guard let components = document.components, let schemas = components.schemas else {
            documentation += "No schemas found in the OpenAPI document.\n"
            return documentation
        }

        documentation += "| OpenAPI Schema | Swift Type | Description |\n"
        documentation += "|---------------|------------|-------------|\n"

        for (name, schema) in schemas.sorted(by: { $0.key < $1.key }) {
            let swiftType = determineSwiftType(for: schema, named: name)
            let description = schema.description ?? ""
            documentation += "| \(name) | \(swiftType) | \(description) |\n"
        }

        documentation += "\n## Type Details\n\n"

        for (name, schema) in schemas.sorted(by: { $0.key < $1.key }) {
            documentation += "### \(name)\n\n"
            documentation += "```swift\n"
            documentation += generateSwiftTypeDefinition(for: schema, named: name)
            documentation += "\n```\n\n"
        }

        return documentation
    }

    /// Determines the Swift type for an OpenAPI schema
    /// - Parameters:
    ///   - schema: The OpenAPI schema
    ///   - name: The name of the schema
    /// - Returns: The Swift type name
    private func determineSwiftType(for schema: JSONSchema, named name: String) -> String {
        switch schema {
        case .string:
            return "String"
        case .number:
            return "Double"
        case .integer:
            return "Int"
        case .boolean:
            return "Bool"
        case .array(let arraySchema):
            let itemType = determineSwiftType(for: arraySchema.items, named: "\(name)Item")
            return "[\(itemType)]"
        case .object:
            return name
        case .reference(let reference):
            let refComponents = reference.ref.components(separatedBy: "/")
            return refComponents.last ?? reference.ref
        case .allOf:
            return name // Composite type
        case .anyOf, .oneOf:
            return name // Union type or enum
        case .not:
            return "Not\(name)" // Rare case
        }
    }

    /// Generates a Swift type definition for an OpenAPI schema
    /// - Parameters:
    ///   - schema: The OpenAPI schema
    ///   - name: The name of the schema
    /// - Returns: A string containing the Swift type definition
    private func generateSwiftTypeDefinition(for schema: JSONSchema, named name: String) -> String {
        switch schema {
        case .object(let objectSchema):
            return generateSwiftStructOrClass(for: objectSchema, named: name)
        case .array(let arraySchema):
            return "typealias \(name) = [\(determineSwiftType(for: arraySchema.items, named: "\(name)Item"))]"
        case .allOf(let schemas):
            return generateCompositeType(for: schemas, named: name)
        case .oneOf(let schemas), .anyOf(let schemas):
            return generateEnumType(for: schemas, named: name)
        default:
            return "// \(name) is mapped to a primitive Swift type: \(determineSwiftType(for: schema, named: name))"
        }
    }

    /// Generates a Swift struct or class for an OpenAPI object schema
    /// - Parameters:
    ///   - objectSchema: The OpenAPI object schema
    ///   - name: The name of the schema
    /// - Returns: A string containing the Swift struct or class definition
    private func generateSwiftStructOrClass(for objectSchema: ObjectSchema, named name: String) -> String {
        let typeKeyword = config.typeFormat == .structs ? "struct" : "class"
        var definition = ""

        if config.includeDocComments, let description = objectSchema.description {
            definition += "/// \(description)\n"
        }

        definition += "\(typeKeyword) \(name): Codable {\n"

        // Properties
        for (propertyName, propertySchema) in objectSchema.properties.sorted(by: { $0.key < $1.key }) {
            if config.includeDocComments, let description = propertySchema.description {
                definition += "    /// \(description)\n"
            }

            let isRequired = objectSchema.required.contains(propertyName)
            let propertyType = determineSwiftType(for: propertySchema, named: "\(name)\(propertyName.capitalized)")
            let optionalMark = isRequired ? "" : "?"

            definition += "    public var \(propertyName): \(propertyType)\(optionalMark)\n"
        }

        // Initializer
        definition += "\n    public init("
        let initParams = objectSchema.properties.sorted(by: { $0.key < $1.key }).map { propertyName, propertySchema in
            let isRequired = objectSchema.required.contains(propertyName)
            let propertyType = determineSwiftType(for: propertySchema, named: "\(name)\(propertyName.capitalized)")
            let optionalMark = isRequired ? "" : "?"
            let defaultValue = isRequired ? "" : " = nil"
            return "\(propertyName): \(propertyType)\(optionalMark)\(defaultValue)"
        }.joined(separator: ", ")
        definition += "\(initParams)) {\n"

        for (propertyName, _) in objectSchema.properties.sorted(by: { $0.key < $1.key }) {
            definition += "        self.\(propertyName) = \(propertyName)\n"
        }

        definition += "    }\n"
        definition += "}"

        return definition
    }

    /// Generates a Swift composite type for an OpenAPI allOf schema
    /// - Parameters:
    ///   - schemas: The OpenAPI schemas to compose
    ///   - name: The name of the composite type
    /// - Returns: A string containing the Swift composite type definition
    private func generateCompositeType(for schemas: [JSONSchema], named name: String) -> String {
        let typeKeyword = config.typeFormat == .structs ? "struct" : "class"
        var definition = "/// A composite type representing a combination of multiple schemas\n"
        definition += "\(typeKeyword) \(name): Codable {\n"

        // Include properties from all schemas
        var propertyIndex = 0
        for schema in schemas {
            if case .object(let objectSchema) = schema {
                for (propertyName, propertySchema) in objectSchema.properties {
                    let propertyType = determineSwiftType(for: propertySchema, named: "\(name)Property\(propertyIndex)")
                    propertyIndex += 1

                    if config.includeDocComments, let description = propertySchema.description {
                        definition += "    /// \(description)\n"
                    }

                    definition += "    public var \(propertyName): \(propertyType)\n"
                }
            }
        }

        definition += "}"
        return definition
    }

    /// Generates a Swift enum type for an OpenAPI oneOf or anyOf schema
    /// - Parameters:
    ///   - schemas: The OpenAPI schemas to create an enum for
    ///   - name: The name of the enum type
    /// - Returns: A string containing the Swift enum type definition
    private func generateEnumType(for schemas: [JSONSchema], named name: String) -> String {
        var definition = "/// A union type that can be one of multiple possible types\n"
        definition += "enum \(name): Codable {\n"

        for (index, schema) in schemas.enumerated() {
            let caseName = "case\(index + 1)"
            let associatedType = determineSwiftType(for: schema, named: "\(name)\(caseName.capitalized)")

            definition += "    case \(caseName)(\(associatedType))\n"
        }

        definition += "}"
        return definition
    }
}
